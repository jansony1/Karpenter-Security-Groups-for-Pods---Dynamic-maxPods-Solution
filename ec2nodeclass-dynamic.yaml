apiVersion: karpenter.k8s.aws/v1
kind: EC2NodeClass
metadata:
  name: m5-dynamic-nodeclass-v2
spec:
  amiFamily: AL2
  amiSelectorTerms:
    - alias: al2@latest
  subnetSelectorTerms:
    - tags:
        karpenter.sh/discovery: "nlb-test-cluster"
  securityGroupSelectorTerms:
    - tags:
        karpenter.sh/discovery: "nlb-test-cluster"
  instanceProfile: "KarpenterNodeInstanceProfile"
  
  userData: |
    #!/bin/bash
    
    # Wait for network to be ready
    sleep 15
    
    # Function to get instance metadata using IMDSv2
    get_instance_metadata() {
        local path=$1
        local token=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" --max-time 5 2>/dev/null)
        if [ ! -z "$token" ]; then
            curl -H "X-aws-ec2-metadata-token: $token" -s --max-time 5 "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null
        fi
    }
    
    # Function to check if instance type supports trunk ENI by querying AWS VPC Resource Controller limits
    is_trunk_eni_compatible() {
        local instance_type=$1
        
        # Download the latest limits from AWS VPC Resource Controller
        local limits_url="https://raw.githubusercontent.com/aws/amazon-vpc-resource-controller-k8s/main/pkg/aws/vpc/limits.go"
        local limits_content=$(curl -s --max-time 30 "$limits_url" 2>/dev/null)
        
        if [ ! -z "$limits_content" ]; then
            # Extract the instance type configuration
            local instance_config=$(echo "$limits_content" | grep -A 15 "\"$instance_type\":" | head -20)
            
            if [ ! -z "$instance_config" ]; then
                # Check if IsTrunkingCompatible is true
                if echo "$instance_config" | grep -q "IsTrunkingCompatible:.*true"; then
                    echo "true"
                    return
                elif echo "$instance_config" | grep -q "IsTrunkingCompatible:.*false"; then
                    echo "false"
                    return
                fi
            fi
        fi
        
        # Fallback: Use known patterns for common instance families
        case $instance_type in
            # Known trunk ENI compatible families (Nitro-based, newer generations)
            m5.*|m5a.*|m5ad.*|m5d.*|m5dn.*|m5n.*|m5zn.*) echo "true" ;;
            m6i.*|m6a.*|m6id.*|m6idn.*|m7i.*|m7a.*) echo "true" ;;
            c5.*|c5a.*|c5ad.*|c5d.*|c5n.*) echo "true" ;;
            c6i.*|c6a.*|c6id.*|c6in.*|c7i.*|c7a.*) echo "true" ;;
            r5.*|r5a.*|r5ad.*|r5b.*|r5d.*|r5dn.*|r5n.*) echo "true" ;;
            r6i.*|r6a.*|r6id.*|r6idn.*|r7i.*|r7a.*) echo "true" ;;
            i3.*|i3en.*|i4i.*) echo "true" ;;
            x2iezn.*|x2idn.*|x2gd.*) echo "true" ;;
            z1d.*) echo "true" ;;
            
            # Known non-trunk ENI compatible families
            t1.*|t2.*|t3.*|t3a.*|t4g.*) echo "false" ;;
            m1.*|m2.*|m3.*|m4.*) echo "false" ;;
            c1.*|c3.*|c4.*) echo "false" ;;
            r3.*|r4.*) echo "false" ;;
            i2.*) echo "false" ;;
            
            # Default: assume not compatible for safety
            *) echo "false" ;;
        esac
    }
    
    # Function to get ENI and IP limits dynamically
    get_eni_limits() {
        local instance_type=$1
        
        # Try to get from AWS VPC Resource Controller limits
        local limits_url="https://raw.githubusercontent.com/aws/amazon-vpc-resource-controller-k8s/main/pkg/aws/vpc/limits.go"
        local limits_content=$(curl -s --max-time 30 "$limits_url" 2>/dev/null)
        
        if [ ! -z "$limits_content" ]; then
            local instance_config=$(echo "$limits_content" | grep -A 15 "\"$instance_type\":" | head -20)
            
            if [ ! -z "$instance_config" ]; then
                local interface_count=$(echo "$instance_config" | grep "Interface:" | head -1 | sed 's/.*Interface:[[:space:]]*\([0-9]*\).*/\1/')
                local ipv4_per_interface=$(echo "$instance_config" | grep "IPv4PerInterface:" | head -1 | sed 's/.*IPv4PerInterface:[[:space:]]*\([0-9]*\).*/\1/')
                local branch_interface=$(echo "$instance_config" | grep "BranchInterface:" | head -1 | sed 's/.*BranchInterface:[[:space:]]*\([0-9]*\).*/\1/')
                
                if [ ! -z "$interface_count" ] && [ ! -z "$ipv4_per_interface" ]; then
                    echo "$interface_count $ipv4_per_interface $branch_interface"
                    return
                fi
            fi
        fi
        
        # Fallback: Use AWS documentation patterns for common instance types
        case $instance_type in
            # T3 series
            t3.nano) echo "2 2 0" ;;
            t3.micro) echo "2 2 0" ;;
            t3.small) echo "3 4 0" ;;
            t3.medium) echo "3 6 0" ;;
            t3.large) echo "3 12 0" ;;
            t3.xlarge) echo "4 15 0" ;;
            t3.2xlarge) echo "4 15 0" ;;
            
            # M5 series
            m5.large) echo "3 10 9" ;;
            m5.xlarge) echo "4 15 18" ;;
            m5.2xlarge) echo "4 15 18" ;;
            m5.4xlarge) echo "8 30 54" ;;
            m5.8xlarge) echo "8 30 54" ;;
            m5.12xlarge) echo "8 30 54" ;;
            m5.16xlarge) echo "15 50 108" ;;
            m5.24xlarge) echo "15 50 108" ;;
            
            # C5 series
            c5.large) echo "3 10 9" ;;
            c5.xlarge) echo "4 15 18" ;;
            c5.2xlarge) echo "4 15 18" ;;
            c5.4xlarge) echo "8 30 54" ;;
            c5.9xlarge) echo "8 30 54" ;;
            c5.12xlarge) echo "8 30 54" ;;
            c5.18xlarge) echo "15 50 108" ;;
            c5.24xlarge) echo "15 50 108" ;;
            
            # Default conservative values
            *) echo "3 10 5" ;;
        esac
    }
    
    # Dynamic maxPods calculation function
    calculate_max_pods() {
        local instance_type=$1
        
        echo "$(date): Starting dynamic maxPods calculation for $instance_type" >> /var/log/karpenter-maxpods.log
        
        # Get ENI limits
        local eni_limits=$(get_eni_limits $instance_type)
        local interface_count=$(echo $eni_limits | cut -d' ' -f1)
        local ipv4_per_interface=$(echo $eni_limits | cut -d' ' -f2)
        local branch_interface=$(echo $eni_limits | cut -d' ' -f3)
        
        # Calculate default maxPods using AWS formula
        local default_max_pods=$(( (interface_count * ipv4_per_interface) - 1 ))
        
        # Check trunk ENI compatibility
        local trunk_eni_compatible=$(is_trunk_eni_compatible $instance_type)
        
        local adjusted_max_pods=$default_max_pods
        local reserved_enis=0
        
        if [ "$trunk_eni_compatible" = "true" ]; then
            # Use branch interface count if available, otherwise estimate
            if [ ! -z "$branch_interface" ] && [ "$branch_interface" != "0" ]; then
                reserved_enis=$branch_interface
            else
                # Conservative estimation: reserve ~30% of total IPs for trunk interfaces
                reserved_enis=$(( (interface_count * ipv4_per_interface) * 30 / 100 ))
            fi
            
            adjusted_max_pods=$(( default_max_pods - reserved_enis ))
            
            echo "$(date): Instance $instance_type supports trunk ENI, reserving $reserved_enis ENIs" >> /var/log/karpenter-maxpods.log
        else
            echo "$(date): Instance $instance_type does NOT support trunk ENI, no ENI reservation needed" >> /var/log/karpenter-maxpods.log
        fi
        
        # Ensure minimum value of 10
        if [ $adjusted_max_pods -lt 10 ]; then
            adjusted_max_pods=10
        fi
        
        echo "$(date): ENI Limits - Interfaces: $interface_count, IPs per Interface: $ipv4_per_interface" >> /var/log/karpenter-maxpods.log
        echo "$(date): Default maxPods: $default_max_pods, Reserved ENIs: $reserved_enis, Final maxPods: $adjusted_max_pods" >> /var/log/karpenter-maxpods.log
        
        echo $adjusted_max_pods
    }
    
    # Get instance type using IMDSv2
    INSTANCE_TYPE=""
    for i in {1..10}; do
        INSTANCE_TYPE=$(get_instance_metadata "instance-type")
        if [ ! -z "$INSTANCE_TYPE" ]; then
            break
        fi
        echo "$(date): Retry $i: Waiting for instance metadata..." >> /var/log/karpenter-maxpods.log
        sleep 10
    done
    
    if [ -z "$INSTANCE_TYPE" ]; then
        echo "$(date): ERROR: Could not retrieve instance type, using default maxPods=20" >> /var/log/karpenter-maxpods.log
        MAX_PODS=20
    else
        # Calculate maxPods dynamically
        MAX_PODS=$(calculate_max_pods $INSTANCE_TYPE)
        
        # Log detailed information
        TRUNK_ENI_COMPATIBLE=$(is_trunk_eni_compatible $INSTANCE_TYPE)
        echo "$(date): Instance Type: $INSTANCE_TYPE" >> /var/log/karpenter-maxpods.log
        echo "$(date): Trunk ENI Compatible: $TRUNK_ENI_COMPATIBLE" >> /var/log/karpenter-maxpods.log
        echo "$(date): Calculated Max Pods: $MAX_PODS" >> /var/log/karpenter-maxpods.log
    fi
    
    # Wait for kubelet config directory to be ready
    while [ ! -d "/etc/kubernetes/kubelet" ]; do
        echo "$(date): Waiting for kubelet config directory..." >> /var/log/karpenter-maxpods.log
        sleep 5
    done
    
    echo "$(date): Using calculated Max Pods value: $MAX_PODS" >> /var/log/karpenter-maxpods.log
    echo "$(date): Security Groups for Pods detection will be performed after cluster join" >> /var/log/karpenter-maxpods.log
    
    # Bootstrap EKS with calculated maxPods
    /etc/eks/bootstrap.sh nlb-test-cluster --kubelet-extra-args "--max-pods=$MAX_PODS"
    
    # Create post-join check script for SG for Pods validation
    cat > /opt/check-sg-for-pods.sh << 'EOFINNER'
    #!/bin/bash
    # Wait for node to fully join cluster
    sleep 60
    
    # Check Security Groups for Pods configuration
    SG_FOR_PODS_ENABLED="false"
    
    # Try multiple methods to check ENABLE_POD_ENI
    if command -v kubectl >/dev/null 2>&1; then
        # Method 1: Check aws-node DaemonSet
        SG_FOR_PODS_ENABLED=$(kubectl get daemonset aws-node -n kube-system -o jsonpath='{.spec.template.spec.containers[0].env[?(@.name=="ENABLE_POD_ENI")].value}' 2>/dev/null || echo "false")
        
        # Method 2: If method 1 fails, check ConfigMap
        if [ "$SG_FOR_PODS_ENABLED" = "false" ] || [ -z "$SG_FOR_PODS_ENABLED" ]; then
            SG_FOR_PODS_ENABLED=$(kubectl get configmap amazon-vpc-cni -n kube-system -o jsonpath='{.data.enable-pod-eni}' 2>/dev/null || echo "false")
        fi
    fi
    
    # Get instance type and trunk ENI compatibility
    INSTANCE_TYPE=$(curl -H "X-aws-ec2-metadata-token: $(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" --max-time 5 2>/dev/null)" -s --max-time 5 http://169.254.169.254/latest/meta-data/instance-type 2>/dev/null)
    
    # Check trunk ENI compatibility using the same logic
    TRUNK_ENI_COMPATIBLE="false"
    case $INSTANCE_TYPE in
        m5.*|m5a.*|m5ad.*|m5d.*|m5dn.*|m5n.*|m5zn.*|m6i.*|m6a.*|m6id.*|m6idn.*|m7i.*|m7a.*) TRUNK_ENI_COMPATIBLE="true" ;;
        c5.*|c5a.*|c5ad.*|c5d.*|c5n.*|c6i.*|c6a.*|c6id.*|c6in.*|c7i.*|c7a.*) TRUNK_ENI_COMPATIBLE="true" ;;
        r5.*|r5a.*|r5ad.*|r5b.*|r5d.*|r5dn.*|r5n.*|r6i.*|r6a.*|r6id.*|r6idn.*|r7i.*|r7a.*) TRUNK_ENI_COMPATIBLE="true" ;;
        i3.*|i3en.*|i4i.*|x2iezn.*|x2idn.*|x2gd.*|z1d.*) TRUNK_ENI_COMPATIBLE="true" ;;
        t1.*|t2.*|t3.*|t3a.*|t4g.*|m1.*|m2.*|m3.*|m4.*|c1.*|c3.*|c4.*|r3.*|r4.*|i2.*) TRUNK_ENI_COMPATIBLE="false" ;;
        *) TRUNK_ENI_COMPATIBLE="unknown" ;;
    esac
    
    # Log comprehensive status
    echo "$(date): === Security Groups for Pods Validation ===" >> /var/log/karpenter-maxpods.log
    echo "$(date): Instance Type: $INSTANCE_TYPE" >> /var/log/karpenter-maxpods.log
    echo "$(date): Trunk ENI Compatible: $TRUNK_ENI_COMPATIBLE" >> /var/log/karpenter-maxpods.log
    echo "$(date): Security Groups for Pods Enabled: $SG_FOR_PODS_ENABLED" >> /var/log/karpenter-maxpods.log
    
    if [ "$SG_FOR_PODS_ENABLED" = "true" ]; then
        if [ "$TRUNK_ENI_COMPATIBLE" = "true" ]; then
            echo "$(date): [OK] Security Groups for Pods is ENABLED and instance supports trunk ENI" >> /var/log/karpenter-maxpods.log
            echo "$(date): ENI reservation is appropriate for this configuration" >> /var/log/karpenter-maxpods.log
        else
            echo "$(date): [WARNING] Security Groups for Pods is ENABLED but instance does NOT support trunk ENI" >> /var/log/karpenter-maxpods.log
            echo "$(date): Pods on this node will not benefit from Security Groups for Pods" >> /var/log/karpenter-maxpods.log
        fi
    else
        if [ "$TRUNK_ENI_COMPATIBLE" = "true" ]; then
            echo "$(date): [INFO] Security Groups for Pods is DISABLED but instance supports trunk ENI" >> /var/log/karpenter-maxpods.log
            echo "$(date): Could enable Security Groups for Pods if needed" >> /var/log/karpenter-maxpods.log
        else
            echo "$(date): [OK] Security Groups for Pods is DISABLED and instance does not support trunk ENI" >> /var/log/karpenter-maxpods.log
            echo "$(date): Standard maxPods calculation is appropriate" >> /var/log/karpenter-maxpods.log
        fi
    fi
    
    # Log final configuration
    CURRENT_MAX_PODS=$(ps aux | grep kubelet | grep -o '\--max-pods=[0-9]*' | cut -d= -f2)
    echo "$(date): Final Max Pods configuration: $CURRENT_MAX_PODS" >> /var/log/karpenter-maxpods.log
    echo "$(date): === Validation Complete ===" >> /var/log/karpenter-maxpods.log
EOFINNER
    
    chmod +x /opt/check-sg-for-pods.sh
    
    # Run check script in background
    nohup /opt/check-sg-for-pods.sh > /var/log/sg-pods-check.log 2>&1 &

  blockDeviceMappings:
    - deviceName: /dev/xvda
      ebs:
        volumeSize: 100Gi
        volumeType: gp3
        encrypted: true
        deleteOnTermination: true
  
  tags:
    ManagedBy: "karpenter"
    Version: "v2-dynamic"
